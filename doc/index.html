<!DOCTYPE html>
<html>
<head>
<title>BrowserDriver API</title>

<script type="text/javascript" src="resources/jquery-1.10.2.js"></script>
<script type="text/javascript" src="resources/PHGDoc.js"></script>
<link rel="stylesheet" href="resources/PHGDoc.css" type="text/css">
<meta charset="utf-8">
<script type="text/javascript">(function (){
var renderer=new Documentor.PHGDoc.PHGDocRenderer();
var api={"ns":{"name":"BrowserDriver API","type":"api","children":{"BrowserDriver":{"type":"namespace","name":"BrowserDriver","children":{"Driver":{"description":"Creates and manages the connection with the server and the execution environment for tests.\r It does not currently provide any means for directly running tests and monitoring test execution and instead relies\r on a separate testing library to do the job (uses QUnit by default). The testing library is hooked by adaptor\r which ensures the library receives proper input and test output is sent to the environment. This way the rules for\r writing a test are those of the library and nothing else.\r\t ","summary":"","config":{},"properties":{"testSources":{"description":"A hash with loaded (or still loading) test source files with the relative file paths as keys.\r\t\t ","summary":"","name":"testSources","dataType":"Object"},"userLibs":{"description":"A hash with loaded (or still loading) user libraries with the relative file paths as keys.\r\t\t ","summary":"","name":"userLibs","dataType":"Object"},"testCache":{"description":"A list of all loaded tests.\r\t\t ","summary":"","name":"testCache","dataType":"Array"},"testsQueue":{"description":"The list of scheduled tests.\r\t\t ","summary":"","name":"testsQueue","dataType":"Array"}},"methods":{"onTestStart":{"description":"Logger method to be called when a test starts running.\r","summary":"","name":"onTestStart","params":[{"description":"A hash with details about the test. Expected keys are \"module\", \"fileName\" and \"name\".\r\t\t ","name":"data","optional":false,"dataType":"Object"}],"returns":{"type":"void","summary":""},"flags":{}},"onTestDone":{"description":"Logger method to be called when a test is over.\r","summary":"","name":"onTestDone","params":[{"description":"A hash with details about the test and the results. Expected keys are \"module\", \"fileName\", \"name\", \"failed\", \"passed\" and \"total\".\r\t\t ","name":"data","optional":false,"dataType":"Object"}],"returns":{"type":"void","summary":""},"flags":{}},"onAssertion":{"description":"Logger method to be called when an assertion is evaluated.\r","summary":"","name":"onAssertion","params":[{"description":"A hash with details about the test and the assertion. Expected keys are \"module\", \"fileName\", \"name\", \"result\", \"expected\", \"actual\" and \"message\".\r\t\t ","name":"data","optional":false,"dataType":"Object"}],"returns":{"type":"void","summary":""},"flags":{}},"onTestRead":{"description":"Must be called when a test is loaded.\r","summary":"","name":"onTestRead","params":[{"description":"A hash with details about the test. Expected keys are \"module\", \"fileName\", \"name\", \"fn\" and \"expect\".\r","name":"testData","optional":false,"dataType":"Object"}],"returns":{"type":"void","summary":""},"flags":{}},"reset":{"description":"Remove all cached data for tests, loaded user libraries and stylesheets.\r\t\t ","summary":"","name":"reset","params":[],"returns":{"type":"void","summary":""},"flags":{}},"attachScript":{"description":"Appends a SCRIPT element to the HEAD.\r","summary":"","name":"attachScript","params":[{"description":"The \"src\" attribute to set.\r","name":"src","optional":false,"dataType":"String"},{"description":"A callback to invoke when the element loads.\r","name":"cb","optional":false,"dataType":"Function"}],"returns":{"type":"void","summary":""},"flags":{}},"loadLib":{"description":"Loads a JS library.\r","summary":"","name":"loadLib","params":[{"description":"The path of the JS library file relative to the \"userLibsPath\" property in the test configuration file (may or may not include the .js file extension).\r","name":"lib","optional":false,"dataType":"String"}],"returns":{"type":"void","summary":""},"flags":{}},"loadTestSource":{"description":"Loads a test source file so tests in it are registered in the environment and ready (but not scheduled) to be run. All loaded tests\r are added to the \"testCache\" list.\r","summary":"","name":"loadTestSource","params":[{"description":"The path of the test file relative to the \"testsPath\" property in the test configuration file.\r","name":"src","optional":false,"dataType":"String"}],"returns":{"type":"void","summary":""},"flags":{}}},"events":{"testRead":{"description":"Fires when a test has been loaded.\r","summary":"","name":"testRead","params":[{"description":"","name":"this","optional":false,"dataType":"BrowserDriver.Driver"},{"description":"","name":"testData","optional":false,"dataType":"Object"}]},"reset":{"description":"Fires after the environment has been reset.\r","summary":"","name":"reset","params":[{"description":"","name":"this","optional":false,"dataType":"BrowserDriver.Driver"}]},"loadLib":{"description":"Fires after a user library's SCRIPT tag has been loaded.\r","summary":"","name":"loadLib","params":[{"description":"","name":"this","optional":false,"dataType":"BrowserDriver.Driver"},{"description":"","name":"lib","optional":false,"dataType":"String"}]},"beforeLoadTestSource":{"description":"Fires before a SCRIPT tag is inserted into the DOM. Returning false from a handler will abort the operation.\r","summary":"","name":"beforeLoadTestSource","params":[{"description":"","name":"this","optional":false,"dataType":"BrowserDriver.Driver"},{"description":"","name":"src","optional":false,"dataType":"String"}]}},"definedIn":"../client/browserDriver.js","flags":{"singleton":true},"type":"class","name":"BrowserDriver.Driver","extends":"EventEmitter"},"Manager":{"description":"Creates and manages the user interface inside a browser window which lets the user interactively manage slave browsers and execute tests.\r The interface can be loaded in more than one browser window and all instances will receive updates from the server.\r ","summary":"","config":{},"properties":{"testModules":{"description":"A list of all loaded test modules. Each module keeps a list of all its tests.\r\t ","summary":"","name":"testModules","dataType":"Array"}},"methods":{},"events":{},"definedIn":"../client/manager/manager.js","flags":{"singleton":true},"type":"class","name":"BrowserDriver.Manager"}},"methods":{},"description":""}},"description":"<pre># JS Browser Driver\r\nThe JS Browser Driver is a Node.JS project originally aiming to simplify writing and running automated UI tests in JS but with the latest development it is now able do much more - it can also run tests inside node.js and in fact is able to manage the execution of code for arbitrary purposes.\r\n\r\n_(more info can be found in the [Wiki](https://github.com/PerformanceHorizonGroup/JS-Browser-Driver/wiki) pages)_\r\n\r\n## Installation\r\n\r\n    npm install browser-driver\r\n    \r\nNote, if the above command growls at you, you probably don't have npm installed. Go grab that at http://npmjs.org/ or simply run:\r\n\r\n    curl http://npmjs.org/install.sh | sh\r\n\r\n## How to use\r\nTest files are organized in suites and for each suite there needs to be a [configuration file](https://github.com/PerformanceHorizonGroup/JS-Browser-Driver/wiki/Configuration-file) written so the server will know how to prepare the resources that tests will need.\r\n\r\nIf you have installed the npm package globally (with `-g`) then you can do:\r\n\r\n    browser-driver configFileName=\"path/to/xxx.conf.json\"\r\n    \r\nor if not then go to the package directory and start it with node like:\r\n\r\n    node server/server.js configFileName=\"path/to/xxx.conf.json\"\r\n\r\n### Setting up the slaves\r\nWithin the conf.json config file, you need to provide an absolute link to each browser. Predictably, this isn't particularly easy as there can be various conflicts with browser windows that are already open. We have gone through this pain many times, so here's a guide for the major browsers:\r\n\r\n- **Chrome**\r\n\r\n    Thankfully Chrome is relatively straightforward, you just need to direct the user data to temp. \r\n    \r\n    - **OS X**, simply point the user data dir to /tmp\r\n        \r\n            {\r\n                \"name\":\"Chrome\",\r\n                \"app\":\"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome\",\r\n                \"args\":[\"--user-data-dir=/tmp\"]\r\n            }\r\n        \r\n    - **Windows**\r\n    \r\n            {\r\n                \"name\":\"Chrome\",\r\n                \"app\":\"C:\\\\Program Files (x86)\\\\GoogleChromePortable\\\\GoogleChromePortable.exe\",\r\n                \"args\":[]\r\n            }\r\n\r\n\r\n- **Firefox**\r\n\r\n    \r\n    - **OS X**\r\n        \r\n        With Firefox, you unfortunately need to create a new profile first, via their Profile Manager. You can do this through the settings, or from the command line you pass the `-ProfileManager` switch to the executable. Lets assume that the profile name you allocate is something really original like \"test\":\r\n    \r\n            {\r\n                \"name\":\"Firefox\",\r\n                \"app\":\"/Applications/Firefox.app/Contents/MacOS/firefox\",\r\n                \"args\":[\"-P test\"]\r\n            }\r\n        \r\n    - **Windows**\r\n    \r\n            {\r\n                \"name\":\"Firefox\",\r\n                \"app\":\"C:\\\\Program Files (x86)\\\\Mozilla Firefox\\\\firefox.exe\",\r\n                \"args\":[]\r\n            }\r\n\r\n\r\n- **IE**\r\n\r\n    \r\n    - **OS X**, what you talkin' bout Willis! Fire up your favourite VM image and follow the naitive example :-)\r\n        \r\n    - **Windows**\r\n    \r\n            {\r\n                \"name\":\"IE\",\r\n                \"app\":\"C:\\\\Program Files (x86)\\\\Internet Explorer\\\\IEXPLORE.EXE\",\r\n                \"args\":[]\r\n            }\r\n\r\n- **node.js (any OS)**\r\n    \r\n        A node.js istance can act as a slave too provided that it runs the slave instance code:\r\n    \r\n            {\r\n                \"name\":\"Node.js\",\r\n                \"app\":\"%CLIENT_ROOT%/node.js/node-slave.js\",\r\n                \"args\":[]\r\n            }\r\n\r\n## Examples\r\nOk, so enough with all the waffle, lets run some pre-baked tests included in the project! Depending on how your `npm` is set up, you need to direct the browser driver to the location of the example tests config file. Before you try to action this, please ensure that you have set up at least 1 browser inside that config file - see above for the gory details. \r\n\r\nOk, so in this example, we will fire up the BrowserDriver on OS X, by pointing to the example tests config:\r\n\r\n    browser-driver configFileName=\"/usr/local/lib/node_modules/browser-driver/examples/sampleTestSuite/testing.conf.json\"\r\n    \r\nIf all is well, you should see the BrowserDriver start up:\r\n\r\n    starting server\r\n    reading configuration file /usr/local/lib/node_modules/browser-driver/examples/sampleTestSuite/testing.conf.json\r\n    Server listening on port 8090 at localhost\r\n    Go to http://localhost:8090/manager/manager.html to manage and run tests\r\n\r\nTime to go to the location it tells you in the above message, `http://localhost:8090/manager/manager.html`, and see the shiny manager page. From here, you can select the browser(s) that you set up and connect to, pick the tests you want to run, and you will see the feedback in real-time in the console. \r\n\r\n## License\r\nThe MIT License, because it rules.\r\n</pre>"}};
api.NSPathSeparator='.';
api.getNSObject=function (path, autoCreate){
			var obj=null,
				pathNames = typeof path=='string'?path.split(this.NSPathSeparator):path;
			if(typeof path=='string')
				pathNames=path.split(this.NSPathSeparator);
			else{
				pathNames=path;
				path=path.join(this.NSPathSeparator);
			}
			if(pathNames.length){
				obj=this.ns;
				var currentPath=[];
				if(pathNames[0]==this.ns.name)
					pathNames.shift();
				while(pathNames.length){
					var p=pathNames.shift();
					currentPath.push(p);
					if(!(p in obj.children)){
						if(autoCreate)
							obj.children[p]={
								type:'namespace',
								name:currentPath.join(this.NSPathSeparator),
								children:{},
								methods:{},
								description:''
							};
						else
							return null;
					}
					obj=obj.children[p];
				}
			}
			return obj;
		};
$(document).ready(function (){ renderer.render(api); });
}());</script>
</head>
<body>
</body>
</html>